<center>阶段六考核</center>

## 一、环境配置

#### 1.搭建虚拟机

首先是下载VM ware以及Centos7进行了虚拟机的搭建

#### 2.vscode远程连接

随后通过vscode上的remote-ssh插件将虚拟机的Linux系统远程连接（确实很方便，终端的界面也更加清晰）

Host centos7

  HostName 192.168.217.128

  User eve-15

#### 3.Golang环境配置

最后则是在Linux下配置Golang环境变量

此过程中出现了一些问题

* 首先是sudo指令无法使用，用户未在sudoers文件中

  * 据此使用su -指令进入root模式

  * 解压golang文件

  * 使用下述代码进入etc.profile中

    ```linux
    sudo vim /etc/profile
    ```

* 进入文件后需要了解如何修改追加文件以及退出保存

1. 打开终端：打开终端应用程序。您可以在应用程序菜单中找到终端选项。
2. 运行Vim：在终端中输入 `vim` 命令，后跟要创建或编辑的文件的名称。例如，要创建一个名为 `example.txt` 的文件，输入以下命令：

```
vim example.txt
```

1. 进入编辑模式：Vim 将以编辑模式打开文件。您可以在此模式下输入和编辑文本。
2. 添加内容：按下 `i` 键以进入插入模式。现在，您可以键入要添加到文件中的文本。
3. 保存并退出：完成文本输入后，**按下 `Esc` 键以退出插入模式**（此处很关键）。然后输入冒号（`:`）进入命令模式。在命令模式中，输入 `wq` 命令，表示"写入"（保存）并"退出" Vim。按下回车键执行命令。

```
:wq
```

如果您只想保存文件而不退出 Vim，可以使用 `:w` 命令。

* 最后则是在profile文件中末尾添加如下语句并验证

```
export GOROOT=/usr/local/go	# 表示源码包路径
export GOPATH=$HOME/go	# 将go的编译环境添加到path中
export PATH=$PATH:$GOROOT/bin:GOPATH/bin	# 开发者go的项目默认路径

# 环境变量配置完毕后使用 source 指令来使环境变量生效。
source /etc/profile
# 验证
go version
```

* 最后则是想在哪里运行go程序则需要进入go程序所在的文件夹内执行

```
go run <xxx>.go
```

## 二、Go 前世今生（C 系历史演变、特性、应用）

#### 1.C系历史演变

Go语言在设计上受到了C系语言的影响。Go语言的语法和基本结构与C语言非常相似，这使得C语言开发者可以相对容易地转换到Go语言。不过，Go语言在设计上也做出了一些改进，以提供更好的开发体验和性能。

可能与随后的思考go语言是否为oop（面向对象编程）有关

C语言中没有类、对象等面向对象编程的概念

#### 2.特性

Go语言具有许多特性，使其在软件开发领域受到广泛关注和采用。以下是一些重要的特性：

* 并发编程：Go语言原生支持轻量级的协程（goroutine）和通信机制（channel），使并发编程变得简单和高效。
* 垃圾回收：Go语言具有自动垃圾回收机制，可以管理内存的分配和释放，减轻了开发人员的负担。
* 快速编译：Go语言的编译速度非常快，可以迅速生成可执行文件。
* 静态类型和类型推导：Go语言是静态类型的语言，但也提供了类型推导的功能，可以减少类型声明的冗余。
* 内置工具：Go语言附带了一些内置工具，如格式化工具（gofmt）、静态代码分析工具（go vet）和性能分析工具（go tool pprof），以提高开发人员的效率。

#### 3.应用

Go语言在许多领域都得到了广泛应用。一些知名的项目和公司使用Go语言来构建高性能的服务和工具。例如，Docker、Kubernetes、Prometheus和Etcd等开源项目都是使用Go语言开发的。Go语言也在Web开发、网络编程、云计算、人工智能等领域得到了广泛应用。

## 三、Go 的执行原理（优先了解 Go 命令相关内容）

#### 1.编写源代码

首先，开发人员使用Go语言编写源代码，源代码以`.go`为文件扩展名。

#### 2.构建

使用Go命令进行构建。构建过程会将源代码编译成机器码或字节码。Go语言的构建工具是Go命令，常用的命令有`go build`、`go install`和`go run`。

- `go build`：将源代码编译为可执行文件，并将其放置在当前目录中。
- `go install`：将源代码编译为可执行文件，并将其安装到Go工作区的`bin`目录中。
- `go run`：直接编译并运行源代码，而不生成可执行文件。

在构建过程中，Go编译器会将Go源代码转换为抽象语法树（Abstract Syntax Tree，AST），然后进行类型检查、语法分析和代码优化。

1. 生成可执行文件或字节码：根据构建的目标不同，Go编译器可以生成不同的输出。对于普通的应用程序，编译器将生成一个可执行文件，可以直接运行。对于库或包，编译器将生成一个包含字节码的归档文件（`.a`文件），供其他程序引用。
2. 运行：生成的可执行文件或字节码可以直接运行。如果使用`go run`命令，Go会在临时目录中生成一个临时的可执行文件，并立即运行它。

需要注意的是，Go语言是一种**静态编译语言**，这意味着**源代码在编译时会被完全翻译成机器码或字节码，而不需要依赖于运行时环境**。因此，Go程序的执行速度通常比动态语言更快。

此外，**Go语言还具有垃圾回收器**（Garbage Collector，GC）来管理内存的分配和释放，这**减轻了开发人员的负担，并帮助避免常见的内存泄漏问题**。垃圾回收器会在运行时自动检测和回收不再使用的内存。

总结来说，Go语言的执行原理包括源代码编写、构建、生成可执行文件或字节码，然后通过运行可执行文件或字节码来执行程序。Go语言的静态编译和内置的垃圾回收器是其执行原理的重要特点。

#### 3.动、静态编译

##### 1.静态编译

- 在静态编译中，源代码在编译时被完全翻译成机器码或字节码，并与编译器生成的运行时库静态链接，形成一个独立的可执行文件。
- 静态编译的可执行文件包含了所有程序运行所需的依赖，因此可以在没有其他依赖项的系统上直接运行。
- 静态编译的优点是执行速度快、部署简单，不需要依赖外部运行时环境。
- 缺点是可执行文件较大，占用更多的磁盘空间，并且在更新程序时需要重新编译和部署。

##### 2.动态编译

- 在动态编译中，源代码在编译时生成一个中间表示（例如字节码），然后在程序运行时由解释器或虚拟机进行解释和执行。
- 动态编译的可执行文件通常较小，因为它们只包含了中间表示和解释器/虚拟机的运行时库。
- 动态编译的优点是更灵活，可以在运行时动态加载和更新代码，无需重新编译和部署整个程序。
- 缺点是由于解释和执行的额外开销，动态编译通常比静态编译的执行速度较慢。

## 四、Go程序开发注意事项

* go源文件以“go”为拓展名
* go应用程序的执行入口时main()函数
* go语言严格区分大小写
* go方法由一条条语句构成，每个语句后不需要分号（go语言会在每行后自动加分号），这也体现出golang的简洁性
* go编译器是一行行进行编译的，因此我们一行就写一条语句，不能把多条语句写在同一个，否则报错
* go语言定义的变量，或者import包如果没有使用到，代码不能编译通过
* 大括号都是成对出现的，缺一不可

## 五、Go基础语法

注释同C语言一致

### Go语言的输入输出

#### 1.输出

标准输出（输出到控制台）：

- `fmt.Print`：输出不带格式的字符串。
- `fmt.Println`：输出字符串并自动换行。
- `fmt.Printf`：使用格式化字符串输出。（类比C语言）

```go
func main() {
    fmt.Print("Hello, ")
    fmt.Println("World!")
    fmt.Printf("The answer is %d\n", 42)
}
```

#### 2.输入

标准输入（从控制台读取输入）：

- `fmt.Scan`：从标准输入读取值，并将其存储到指定的变量中。
- `fmt.Scanln`：从标准输入读取一行，并将其存储到指定的变量中。
- `fmt.Scanf`：使用格式化字符串从标准输入读取值。（类比C语言）

```go
fmt.Print("Enter your name: ")
    fmt.Scan(&name)

    fmt.Print("Enter your age: ")
    fmt.Scanln(&age)
```

### 1.包、变量和函数

#### 1.包

每个 Go 程序都是由包构成的，程序从 `main` 包开始运行

* 导入

```go
import (
	"fmt"
	"math"
)
```

* 导出名

```go
func main() {
	fmt.Println(math.pi)
}
func main() {
	fmt.Println(math.Pi)
}
第二个Pi以大写字母开头，那么它就是已导出的

第一个pi 并未以大写字母开头，所以它们是未导出的

在导入一个包时，你只能引用其中已导出的名字。任何“未导出”的名字在该包外均无法访问
```

#### 2.函数

函数可以没有参数或接受多个参数，注意类型在变量名 **之后**

```go
x int, y int
```

当连续两个或多个函数的已命名形参类型相同时，除最后一个类型以外，其它都可以省略。

```go
x, y int
```

函数可以返回任意数量的返回值。

* 命名返回值

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```

Go 的返回值可被命名，它们会被视作定义在函数顶部的变量

没有参数的 `return` 语句返回已命名的返回值。也就是 `直接` 返回

#### 3.变量

`var` 语句用于声明一个变量列表，跟函数的参数列表一样，类型在最后，`var` 语句可以出现在包或函数级别

占位符类型

- `%d`：有符号十进制整数（`int` 类型）
- `%f`：浮点数（`float64` 类型）
- `%s`：字符串（`string` 类型）
- `%t`：布尔值（`bool` 类型）
- `%v`：通用格式，根据值的类型动态选择格式化方式
- `%T`：打印值的类型
- `%b`：二进制表示
- `%o`：八进制表示
- `%x`：十六进制表示
- `%c`：Unicode 字符
- `%p`：指针的十六进制表示



变量初始化

```go
var i, j int = 1, 2
func main() {
	var c, python, java = true, false, "no!"
	fmt.Println(i, j, c, python, java)
}
```

如果初始化值已存在（每个变量对应一个），则可以省略类型；变量会从初始值中获得类型。

* 没有明确初始值的变量声明会被赋予它们的 **零值**。

  * 零值是：

    - 数值类型为 `0`(不同与C语言不赋初值伪随机数)

    - 布尔类型为 `false`

    - 字符串为 `""`（空字符串）

* 短变量声明

在函数中，简洁赋值语句 `:=` 可在类型明确的地方代替 `var` 声明

```go
name := "Alice"
```

函数外的每个语句都必须以关键字开始（`var`, `func` 等等），因此 `:=` 结构不能在函数外使用。

#### 4.基本类型

Go语言中的基本数据类型：

- `bool`：布尔类型，表示真或假的值。
- `string`：字符串类型，表示一串字符。
- `int`、`int8`、`int16`、`int32`、`int64`：有符号整数类型，分别表示不同位数的整数。
- `uint`、`uint8`、`uint16`、`uint32`、`uint64`、`uintptr`：无符号整数类型，分别表示不同位数的非负整数。
- `byte`：`byte` 是 `uint8` 的别名，表示一个字节。
- `rune`：`rune` 是 `int32` 的别名，表示一个 Unicode 码点，用于表示字符。
- `float32`、`float64`：浮点数类型，分别表示单精度浮点数和双精度浮点数。
- `complex64`、`complex128`：复数类型，分别表示具有实部和虚部的复数，其中后者使用更高的精度

#### 5.类型转换

一些关于数值的转换：

```go
var i int = 42
var f float64 = float64(i)
var u uint = uint(f)
```

或者，更加简单的形式：

```go
i := 42
f := float64(i)
u := uint(f)
```

*  类型推导

当右值声明了类型时，新变量的类型与其相同：

```go
var i int
j := i // j 也是一个 int
```

不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 `int`, `float64` 或 `complex128` 了，这取决于常量的精度：

```go
i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
```

#### 6.常量

* 常量的声明与变量类似，只不过是使用 `const` 关键字。
* 常量可以是字符、字符串、布尔值或数值。
* 常量不能用 `:=` 语法声明。

##### 数值常量

数值常量是高精度的 **值**。

一个未指定类型的常量由上下文来决定其类型。

（`int` 类型最大可以存储一个 64 位的整数，有时会更小。）

（`int` 可以存放最大64位的整数，根据平台不同有时会更少。）

### 2.流程控制语句：for、if、else、switch、defer

#### 1.for循环

##### 语法

Go 只有一种循环结构：`for` 循环。（不同于C语言）

基本的 `for` 循环由三部分组成，它们用分号隔开：

- 初始化语句：在第一次迭代前执行
- 条件表达式：在每次迭代前求值
- 后置语句：在每次迭代的结尾执行

初始化语句通常为一句短变量声明，该变量声明仅在 `for` 语句的作用域中可见。

一旦条件表达式的布尔值为 `false`，循环迭代就会终止。

```go
for i := 0; i < 10; i++ {
		sum += i
	}
//注意：和 C、Java、JavaScript 之类的语言不同，Go 的 for 语句后面的三个构成部分外没有小括号， 大括号 { } 则是必须的
```

初始化语句和后置语句是可选的(即可以没有初始化和后置语句)

```go
for ; sum < 1000; {
		sum += sum
	}
```

##### for 是 Go 中的 “while

C 的 `while` 在 Go 中叫做 `for`

```go
for sum < 1000 {
		sum += sum
	}
```

##### 无限循环

如果省略循环条件，该循环就不会结束，因此无限循环可以写得很紧凑

```go
for {
	}
```

#### 2.if判断

##### 语法

Go 的 `if` 语句与 `for` 循环类似，表达式外无需小括号 `( )` ，而大括号 `{ }` 则是必须的。

```go
if x < 0 {
		return sqrt(-x) + "i"
	}
```

同 `for` 一样， `if` 语句可以在条件表达式前执行一个简单的语句。

该语句声明的变量作用域仅在 `if` 之内。**(很重要容易忽略)**

##### if和else

在 `if` 的简短语句中声明的变量同样可以在任何对应的 `else` 块中使用。

```go
if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
```

#### 3.switch

Go 的 switch 语句类似于 C，不过 Go 只运行选定的 case，而非之后所有的 case。 实际上，Go 自动提供了在这些语言中每个 case 后面所需的 `break` 语句。 除非以 `fallthrough` 语句结束，否则分支会自动终止。 Go 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。

switch 的 case 语句从上到下顺次执行，直到匹配成功时停止

```go
switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
	}
```

#### 4.defer

defer 语句会将函数推迟到外层函数返回之后执行。

```go
func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
```

推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。(栈：先放进去的在最底层，拿出的时候1先拿出最后放进去的最上层)

### 3.struct、slice、映射

#### 1.指针

Go 语言的指针提供了直接操作内存地址的能力，可以用于间接访问和修改变量的值。使用 & 和 * 操作符可以获取变量的地址和声明指针变量

```go
func main() {
    // 声明一个整数变量
    var num int = 42

    // 声明一个指向整数的指针变量，并将其指向 num 的内存地址
    var ptr *int = &num

    // 打印指针的值和指向的值
    fmt.Println("Pointer:", ptr)
    fmt.Println("Value at pointer:", *ptr)

    // 修改指针所指向的值
    *ptr = 100

    // 打印修改后的值
    fmt.Println("Modified value:", num)
}
```

可以类比C语言理解但是比C语言简洁内容也比C语言的指针少

#### 2.结构体

一个结构体（`struct`）就是一组字段，结构体字段使用点号来访问

##### 1.结构体指针

如果我们有一个指向结构体的指针 `p`，那么可以通过 `(*p).X` 来访问其字段 `X`。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 `p.X` 就可以。

```go
func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 1e9
	fmt.Println(v)
}
```

#### 3.数组

类型 `[n]T` 表示拥有 `n` 个 `T` 类型的值的数组

```go
var a [10]int
//会将变量 a 声明为拥有 10 个整数的数组。
```

#### 4.切片

每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。

切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔：

```go
a[low : high]
```

它会选择一个半开区间，包括第一个元素，但排除最后一个元素。

以下表达式创建了一个切片，它包含 `a` 中下标从 1 到 3 的元素：

```go
a[1:4]
```

##### 切片的默认行为

对于数组

```go
var a [10]int
```

来说，以下切片是等价的：

```go
a[0:10]
a[:10]
a[0:]
a[:]
```

##### 用make创建切片

切片可以用内建函数 `make` 来创建，这也是你创建动态数组的方式。

`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：

```go
a := make([]int, 5)  // len(a)=5
```

要指定它的容量，需向 `make` 传入第三个参数：

```go
b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
```

##### 二维切片

类似C语言的二重指针

```go
func main() {
	// 创建一个井字板（经典游戏）
	board := [][]string{
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
		[]string{"_", "_", "_"},
	}
// 两个玩家轮流打上 X 和 O
board[0][0] = "X"
board[2][2] = "O"
board[1][2] = "X"
board[1][0] = "O"
board[0][2] = "X"

for i := 0; i < len(board); i++ {
	fmt.Printf("%s\n", strings.Join(board[i], " "))
}
```
##### 向切片追加元素

为切片追加新的元素是种常用的操作，为此 Go 提供了内建的 `append` 函数。内建函数的[文档](https://go-zh.org/pkg/builtin/#append)对此函数有详细的介绍。

```go
func append(s []T, vs ...T) []T
//`append` 的第一个参数 `s` 是一个元素类型为 `T` 的切片，其余类型为 `T` 的值将会追加到该切片的末尾。

//`append` 的结果是一个包含原切片所有元素加上新添加元素的切片。

//当 `s` 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。
```



```go
func main() {
	var s []int
	printSlice(s)
// 添加一个空切片
s = append(s, 0)
printSlice(s)

// 这个切片会按需增长
s = append(s, 1)
printSlice(s)

// 可以一次性添加多个元素
s = append(s, 2, 3, 4)
printSlice(s)
}
```
#### 5.range

`for` 循环的 `range` 形式可遍历切片或映射。

当使用 `for` 循环遍历切片时，每次迭代都会**返回两个值**。**第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。**

ps：在range中如果只有一个变量接收则接收索引值若为两个变量接收则为接收索引值和对应元素的值，如下实例

可以将下标或值赋予 `_` 来忽略它。

```go
for i, _ := range pow
for _, value := range pow
```

若你只需要索引，忽略第二个变量即可。

```go
for i := range pow
```

#### 6.映射（map）

可以类比python的字典

映射将键映射到值

```go
func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}
	fmt.Println(m["Bell Labs"])
}
```

运行结果

```go
{40.68433 -74.39967}
```

##### 修改映射

在映射 `m` 中插入或修改元素：

```go
m[key] = elem
```

获取元素：

```go
elem = m[key]
```

删除元素：

```go
delete(m, key)
```

通过双赋值检测某个键是否存在：

```go
elem, ok = m[key]
```

若 `key` 在 `m` 中，`ok` 为 `true` ；否则，`ok` 为 `false`。

若 `key` 不在映射中，那么 `elem` 是该映射元素类型的零值。

同样的，当从映射中读取某个不存在的键时，结果是映射的元素类型的零值

### 4.方法（method）

在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。