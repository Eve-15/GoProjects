<center>阶段七心得</center>

## 一、TCP

### 1.tcp的了解

有关于tcp的简单熟悉已经在阶段七考核中提到

### 2.tcp的demo

* 体会

1. 这次的demo给我的最多的体会就是关于服务器和客户端的认识，由于游戏玩的比较多，所以就对联机比较感兴趣，因此此次也是想把之前的纸牌游戏做成联机的。
2. 让我初次了解并接触基本的网络编程，真正的感受到了互联网是如何彼此之间传输信息的，感觉比较灵活相比于普通的编程题

* 所学

1. 首先是学习并应用简单的C/S架构，初步实现了服务器和客户端之间的交互，也初步感受到了go语言对并发的处理（但感觉只是了解皮毛，既然处理并发是go语言一大特点和优势，希望在以后的学习中能更深入的理解学习，灵活处理并发）

2. 对结构体有了更深刻的认知，大部分的数据都储存在结构体中，希望在下次数据库的学习能优化

3. 学习并初步使用互斥锁（Mutex），用于保护共享资源的同步机制，使用互斥锁可以有效地避免竟态条件和数据竞争，确保共享资源的正确访问（尤其在此次demo中使用了多个客户端连接服务器，尤为需要正确访问共享资源）

   ```go
   import(
   	"sync"
   )
   
   var mutex sync.Mutex
   
   clientInfo.mutex.Lock()
   //要访问的内容
   clientInfo.mutex.Unlock()
   ```

4. 学习并初步使用等待组（WaitGroup），因为demo中需要两名玩家进行各自回合，当两者均得到最终结果后再进行比较，所以此过程中就需要使用等待组

   等待组是一种在并发编程中用于等待一组协程（goroutine）完成执行的同步机制

   ```go
   import(
   	"sync"
   )
   //创建等待组，首先要创建一个WaitGroup对象
   var wg sync.Mutex
   //添加协程到等待组
   wg.Add(1)
   //协程执行任务：被添加到等待组的协程执行自己的任务
   
   //任务完成并减少计数：在协程完成自己的任务后，调用等待组的Done()方法来减少计数
   wg.Done()
   //等待协程组完成：在需要1等待协程组完成的地方，调用等待组的Wait()方法，它会阻塞当前协程，直到等待组的计数减少到0
   wg.Wait()
   ```

   在应用过程中发现，需要理解等待组的整个原理，等待组加入的地方也需要思考，但是在初步添加等待组后仍然无法实现预期效果，每个协程进行完后都会执行wg.Wait()后的内容，于是加入计数器见下文

5. 了解并应用计数器，实现了预期两个客户端都执行完毕后广播游戏结果

   ```go
   var clientCount int
   var maxClients int = 2
   
   if clientCount == maxClients {
   	clientInfo.wg.Wait()
   }
   ```

* 不足之处

1. 首先是没有考虑到运行的性能和内存的占用
2. 游戏实现十分僵硬，不能向对应客户端传输对应的内容，只能通过遍历结构体达到广播的效果
3. 对于各种变量的引用理解不到位（感觉在学习C语言时候没认真）
4. demo中仍有细节的地方没有打磨，比如一名玩家在等待另一名玩家结束的过程中没有设置提示
5. 对于指针的理解和应用仍然很皮毛，在以后的学习中多在应用中理解，做到灵活使用
6. 在学习go文档的过程中略显吃力，纯文档的学习可能需要更多经验积累，但会继续理解
7. 命名不是很规范需要学习（参考驼峰命名法）
8. 项目结构及代码比较乱，在以后学习中需要注意（参考mvc项目架构）
9. 我觉得在真正的服务器和客户端应用中，客户端的实时数据应该要返回给服务器，或者服务器一直监控客户端数据以便后台人员进行观察及控制

## 二、HTTP

### 1.http的了解

有关于http的简单熟悉已经在阶段七考核中提到
